<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Recorder - AI Powered</title>
    <style>
        :root {
            --primary-color: #5acee3;
            --primary-dark: #1b7d8f;
            --secondary-color: #823ca6;
            --background-dark: #1a084e;
            --background-light: #3b0e68;
            --text-light: #ffffff;
            --text-dark: #333333;
            --success-color: #4cd137;
            --warning-color: #ffa502;
            --error-color: #ff4757;
            --border-radius: 15px;
            --transition-speed: 0.3s;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            overflow: hidden;
            background: #3b0e68;
            background: radial-gradient(circle, var(--background-light) 0%, var(--background-dark) 100%);
            font-family: 'Arial', sans-serif;
            color: var(--text-light);
            height: 100vh;
        }

        .header {
            position: absolute;
            top: 30px;
            left: 0;
            right: 0;
            text-align: center;
            z-index: 10;
            padding: 0 20px;
        }

        .header h1 {
            margin-bottom: 10px;
            font-size: 2.8rem;
            font-weight: 700;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 2px 15px rgba(90, 206, 227, 0.4);
            letter-spacing: -0.5px;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
            font-weight: 300;
            letter-spacing: 0.5px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .mic-container {
            position: relative;
            width: 280px;
            height: 280px;
            border-radius: 50%;
            background: rgba(26, 8, 78, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all var(--transition-speed) ease;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4), 
                        inset 0 5px 15px rgba(255, 255, 255, 0.1);
            animation: circle-size 3s ease-in-out infinite alternate;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .mic-container:hover {
            transform: translate(-50%, -50%) scale(1.05);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5), 
                        inset 0 5px 15px rgba(255, 255, 255, 0.2);
        }

        .mic-container.recording {
            animation: circle-size-recording 0.5s ease-in-out infinite alternate;
            background: rgba(255, 71, 87, 0.2);
            border-color: rgba(255, 71, 87, 0.3);
        }

        .mic-container.processing {
            animation: pulse-container 2s infinite;
            background: rgba(255, 165, 2, 0.2);
            border-color: rgba(255, 165, 2, 0.3);
        }

        .mic {
            position: relative;
            color: #fff;
            width: 130px;
            height: 130px;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--background-dark), var(--background-light));
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4),
                        inset 0 2px 10px rgba(255, 255, 255, 0.1);
            transition: all var(--transition-speed) ease;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .mic::before, .mic::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 100%;
            z-index: 2;
            box-shadow: 0 0 20px 20px #1c084f;
        }

        .mic::before {
            width: 400px;
            height: 400px;
            background-color: #1a084e;
        }

        .mic::after {
            width: 250px;
            height: 250px;
            background-color: #2f1e5f;
            animation: circle-size 0.8s linear infinite alternate;
        }

        .mic.recording {
            background: linear-gradient(45deg, var(--error-color), #ff6b81);
            transform: scale(1.05);
        }
        
        .mic.recording::after {
            background-color: #ff4757;
            animation: circle-size-recording 0.5s linear infinite alternate;
        }
        
        @keyframes pulse-container {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4), 
                            inset 0 5px 15px rgba(255, 255, 255, 0.1);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.03);
                box-shadow: 0 20px 45px rgba(0, 0, 0, 0.5), 
                            inset 0 5px 15px rgba(255, 255, 255, 0.2);
            }
        }

        .mic-icon {
            box-sizing: border-box;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(5);
            display: block;
            width: 16px;
            height: 12px;
            border-bottom-left-radius: 120px;
            border-bottom-right-radius: 120px;
            border: 2px solid var(--primary-color);
            border-top: 0;
            margin-top: 20px;
            z-index: 3;
            transition: all var(--transition-speed) ease;
        }

        .mic-container:hover .mic-icon {
            transform: translate(-50%, -50%) scale(5.2);
            border-color: var(--primary-color);
        }

        .mic-icon::before, .mic-icon::after {
            content: "";
            display: block;
            box-sizing: border-box;
            position: absolute;
            transition: all var(--transition-speed) ease;
        }

        .mic-icon::before {
            width: 2px;
            height: 5px;
            top: calc(100% + 1px);
            left: 50%;
            transform: translate(-50%, 0);
            background-color: var(--primary-color);
        }

        .mic-icon::after {
            border: 2px solid var(--primary-color);
            width: 8px;
            height: 18px;
            left: 50%;
            top: -10px;
            border-radius: 4px;
            transform: translate(-50%, 0);
        }

        .mic-container.recording .mic-icon,
        .mic-container.recording .mic-icon::after {
            border-color: var(--error-color);
        }

        .mic-container.recording .mic-icon::before {
            background-color: var(--error-color);
        }

        .mic-shadow {
            width: 400px;
            height: 400px;
            position: absolute;
            top: 50%;
            left: 50%;
            border-radius: 100%;
            z-index: 1;
            box-shadow: 
                10px -55px 30px 15px var(--secondary-color), 
                24px -10px 47px 10px #aab3d2, 
                -21px -25px 97px 10px var(--primary-color), 
                51px 5px 17px 10px var(--primary-dark), 
                3px 2px 77px 10px #f30bf5;
            animation: shadow-rotate 1.5s linear infinite;
            transform-origin: center;
            opacity: 0.8;
            filter: blur(2px);
        }
        
        .mic-container:hover .mic-shadow {
            opacity: 1;
            filter: blur(1px);
        }

        .status {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 10;
            background: rgba(26, 8, 78, 0.6);
            padding: 15px 25px;
            border-radius: var(--border-radius);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            min-width: 300px;
            transition: all var(--transition-speed) ease;
        }

        .status-text {
            font-size: 1.3rem;
            margin-bottom: 15px;
            min-height: 30px;
            font-weight: 500;
            letter-spacing: 0.5px;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: all var(--transition-speed) ease;
        }

        .status-indicator {
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 10px;
            background-color: var(--success-color);
            animation: pulse 2s infinite;
            box-shadow: 0 0 10px var(--success-color);
            transition: all var(--transition-speed) ease;
        }

        .status-indicator.recording {
            background-color: var(--error-color);
            animation: pulse-recording 0.5s infinite;
            box-shadow: 0 0 15px var(--error-color);
        }

        .status-indicator.processing {
            background-color: var(--warning-color);
            animation: pulse 1s infinite;
            box-shadow: 0 0 15px var(--warning-color);
        }

        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 10;
            background: rgba(26, 8, 78, 0.6);
            padding: 15px 25px;
            border-radius: var(--border-radius);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 30px;
            background: linear-gradient(45deg, var(--background-dark), var(--background-light));
            color: var(--text-light);
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: 500;
            letter-spacing: 0.5px;
            transition: all var(--transition-speed) ease;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: all 0.5s ease;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .btn:active {
            transform: translateY(1px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .primary-btn {
            background: linear-gradient(45deg, var(--primary-color), var(--primary-dark));
            color: var(--background-dark);
            font-weight: 600;
            border-color: rgba(90, 206, 227, 0.3);
        }
        
        .primary-btn:hover {
            background: linear-gradient(45deg, var(--primary-dark), var(--primary-color));
            border-color: rgba(90, 206, 227, 0.6);
        }
        
        .primary-btn:disabled {
            background: linear-gradient(45deg, #a0a0a0, #808080);
            border-color: rgba(160, 160, 160, 0.3);
        }

        .output-panel {
            position: absolute;
            top: 120px;
            right: 30px;
            width: 380px;
            max-height: 70vh;
            background: rgba(26, 8, 78, 0.8);
            border-radius: var(--border-radius);
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            overflow-y: auto;
            z-index: 10;
            display: none;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
            transition: all var(--transition-speed) ease;
            scrollbar-width: thin;
            scrollbar-color: var(--primary-color) rgba(26, 8, 78, 0.5);
        }
        
        .output-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        .output-panel::-webkit-scrollbar-track {
            background: rgba(26, 8, 78, 0.5);
            border-radius: 10px;
        }
        
        .output-panel::-webkit-scrollbar-thumb {
            background-color: var(--primary-color);
            border-radius: 10px;
        }

        .output-panel h3 {
            margin-bottom: 20px;
            color: var(--primary-color);
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
        }

        .output-text {
            background: rgba(47, 30, 95, 0.5);
            padding: 18px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            line-height: 1.7;
            min-height: 120px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            font-size: 1.05rem;
            position: relative;
        }
        
        .message-container {
            margin-bottom: 25px;
            animation: fadeIn 0.5s ease-in-out;
        }
        
        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }
        
        .message-role {
            font-weight: 600;
            color: var(--primary-color);
        }
        
        .message-time {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8rem;
        }
        
        .user-message {
            background: rgba(90, 206, 227, 0.15);
            border-left: 3px solid var(--primary-color);
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 15px;
        }
        
        .ai-message {
            background: rgba(130, 60, 166, 0.15);
            border-left: 3px solid var(--secondary-color);
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 15px;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .server-status {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(26, 8, 78, 0.8);
            padding: 12px 20px;
            border-radius: var(--border-radius);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10;
            backdrop-filter: blur(5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            transition: all var(--transition-speed) ease;
            display: flex;
            align-items: center;
            font-size: 0.95rem;
            letter-spacing: 0.5px;
        }

        .server-status.online {
            border-color: var(--success-color);
            box-shadow: 0 5px 15px rgba(76, 209, 55, 0.2);
        }

        .server-status.offline {
            border-color: var(--error-color);
            box-shadow: 0 5px 15px rgba(255, 71, 87, 0.2);
        }
        
        .server-status:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.3);
        }

        @keyframes circle-size {
            0% {
                transform: translate(-50%, -50%) scale(0.95);
                box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4), 
                            inset 0 5px 15px rgba(255, 255, 255, 0.1);
            }
            50% {
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5), 
                            inset 0 8px 20px rgba(255, 255, 255, 0.15);
            }
            100% {
                transform: translate(-50%, -50%) scale(0.95);
                box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4), 
                            inset 0 5px 15px rgba(255, 255, 255, 0.1);
            }
        }

        @keyframes circle-size-recording {
            0% {
                transform: translate(-50%, -50%) scale(0.98);
                box-shadow: 0 15px 35px rgba(255, 71, 87, 0.3), 
                            inset 0 5px 15px rgba(255, 255, 255, 0.1);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.05);
                box-shadow: 0 20px 40px rgba(255, 71, 87, 0.4), 
                            inset 0 8px 20px rgba(255, 255, 255, 0.15);
            }
            100% {
                transform: translate(-50%, -50%) scale(0.98);
                box-shadow: 0 15px 35px rgba(255, 71, 87, 0.3), 
                            inset 0 5px 15px rgba(255, 255, 255, 0.1);
            }
        }

        @keyframes shadow-rotate {
            from {
                transform: translate(-50%, -50%) rotate(0deg);
                opacity: 0.7;
            }
            50% {
                opacity: 0.9;
            }
            to {
                transform: translate(-50%, -50%) rotate(360deg);
                opacity: 0.7;
            }
        }

        @keyframes pulse {
            0% {
                opacity: 0.8;
                box-shadow: 0 0 5px var(--success-color);
            }
            50% {
                opacity: 1;
                box-shadow: 0 0 15px var(--success-color);
            }
            100% {
                opacity: 0.8;
                box-shadow: 0 0 5px var(--success-color);
            }
        }

        @keyframes pulse-recording {
            0% {
                opacity: 0.9;
                transform: scale(1);
                box-shadow: 0 0 5px var(--error-color);
            }
            50% {
                opacity: 1;
                transform: scale(1.3);
                box-shadow: 0 0 20px var(--error-color);
            }
            100% {
                opacity: 0.9;
                transform: scale(1);
                box-shadow: 0 0 5px var(--error-color);
            }
        }

        .wave-animation {
            position: absolute;
            bottom: 180px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            z-index: 10;
            padding: 15px;
            background: rgba(26, 8, 78, 0.4);
            border-radius: var(--border-radius);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        .wave {
            display: inline-block;
            width: 5px;
            height: 20px;
            background: var(--primary-color);
            margin: 0 3px;
            border-radius: 3px;
            animation: wave 1s infinite;
            box-shadow: 0 0 8px var(--primary-color);
        }

        .wave:nth-child(1) { animation-delay: 0.0s; height: 15px; }
        .wave:nth-child(2) { animation-delay: 0.1s; height: 25px; }
        .wave:nth-child(3) { animation-delay: 0.2s; height: 35px; }
        .wave:nth-child(4) { animation-delay: 0.3s; height: 25px; }
        .wave:nth-child(5) { animation-delay: 0.4s; height: 15px; }

        .mic-container.recording .wave {
            background: var(--error-color);
            box-shadow: 0 0 8px var(--error-color);
        }

        @keyframes wave {
            0%, 100% { transform: scaleY(0.6); opacity: 0.6; }
            50% { transform: scaleY(1.2); opacity: 1; }
        }
        
        @keyframes fadeInLeft {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>RIZZA AI</h1>
        <p>Click to start recording your voice</p>
    </div>

    <div class="server-status" id="serverStatus">
        <span class="status-indicator" id="serverIndicator"></span>
        <span id="serverText">Server: Connecting...</span>
    </div>

    <div class="mic-container" id="micContainer">
        <div class="mic" id="mic">
            <i class="mic-icon"></i>
            <div class="mic-shadow"></div>
        </div>
    </div>

    <div class="status">
        <div class="status-text" id="statusText">Ready to record</div>
        <div class="wave-animation" id="waveAnimation">
            <div class="wave"></div>
            <div class="wave"></div>
            <div class="wave"></div>
            <div class="wave"></div>
            <div class="wave"></div>
        </div>
    </div>

    <div class="controls" style="display: none;">
        <button class="btn primary-btn" id="sendBtn">Send</button>
    </div>

    <div class="output-panel" id="outputPanel">
        <h3>Transcription Results</h3>
        <div class="output-text" id="outputText">You said: </div>
    </div>

    <script>
        class VoiceRecorder {
            constructor() {
                this.isRecording = false;
                this.mediaRecorder = null;
                this.audioChunks = [];
                this.serverRunning = false;
                this.sessionId = null;
                this.responseAudio = null;
                this.isProcessing = false;
                this.pollingInterval = null;
                this.ffmpegWarningShown = false;
                this.silenceTimer = null;
                this.lastSpeechTime = Date.now();
                this.silenceThreshold = 2000; // 2 seconds of silence before auto-sending
                this.currentAudio = null; // Track current audio element for proper cleanup
                
                this.initializeElements();
                this.setupEventListeners();
                this.checkServerStatus();
                this.startNewSession();
            }

            initializeElements() {
                this.micContainer = document.getElementById('micContainer');
                this.mic = document.getElementById('mic');
                this.statusText = document.getElementById('statusText');
                this.sendBtn = document.getElementById('sendBtn');
                this.outputPanel = document.getElementById('outputPanel');
                this.outputText = document.getElementById('outputText');
                this.waveAnimation = document.getElementById('waveAnimation')
                this.serverStatus = document.getElementById('serverStatus');
                this.serverIndicator = document.getElementById('serverIndicator');
                this.serverText = document.getElementById('serverText');
                
                // Create a real-time transcription display
                this.realtimeTranscription = document.createElement('div');
                this.realtimeTranscription.className = 'realtime-transcription';
                this.realtimeTranscription.style.cssText = `
                    position: fixed;
                    top: 120px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(26, 8, 78, 0.85);
                    padding: 15px 25px;
                    border-radius: var(--border-radius);
                    border: 1px solid rgba(255, 255, 255, 0.15);
                    color: var(--text-light);
                    max-width: 600px;
                    min-width: 300px;
                    text-align: center;
                    z-index: 10;
                    display: none;
                    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
                    backdrop-filter: blur(5px);
                    animation: fadeIn 0.3s ease-out;
                    line-height: 1.5;
                    letter-spacing: 0.5px;
                    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                `;
                this.realtimeTranscription.innerHTML = `You are saying: <span id="realtime-transcription-text"></span>`;
                document.body.appendChild(this.realtimeTranscription);
                this.realtimeTranscriptionText = document.getElementById('realtime-transcription-text');
            }

            setupEventListeners() {
                this.micContainer.addEventListener('click', () => this.toggleRecording());
                // Send button removed from functionality - fully automatic now
            }

            async startNewSession() {
                try {
                    const response = await fetch('http://localhost:5000/start_session', {
                        method: 'POST'
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        this.sessionId = data.session_id;
                        console.log('New session started:', this.sessionId);
                    }
                } catch (error) {
                    console.error('Failed to start session:', error);
                }
            }

            async checkServerStatus() {
                try {
                    const response = await fetch('http://localhost:5000/health');
                    if (response.ok) {
                        this.serverRunning = true;
                        this.updateServerStatus('Server Online', 'online');
                    } else {
                        throw new Error('Server not responding');
                    }
                } catch (error) {
                    this.serverRunning = false;
                    this.updateServerStatus('Server Offline', 'offline');
                }
            }

            updateServerStatus(text, status) {
                this.serverText.textContent = text;
                this.serverIndicator.className = `status-indicator ${status}`;
                this.serverStatus.className = `server-status ${status}`;
                
                // Check for ffmpeg warning in server logs
                if (status === 'online' && !this.ffmpegWarningShown) {
                    // Show a warning about potential audio processing issues
                    this.checkForAudioProcessingIssues();
                }
            }
            
            async checkForAudioProcessingIssues() {
                try {
                    const response = await fetch('http://localhost:5000/transcribe', {
                        method: 'POST',
                        body: new FormData() // Empty form to test if server responds with proper error
                    });
                    
                    if (response.status === 400) {
                        // Server is working but expecting audio file
                        // This is normal behavior
                    } else {
                        // Unexpected response, might indicate issues
                        this.showWarningMessage('Audio processing might have issues. Make sure ffmpeg is installed.');
                    }
                } catch (error) {
                    console.error('Error checking audio processing:', error);
                }
                
                this.ffmpegWarningShown = true;
            }
            
            showWarningMessage(message) {
                const warningDiv = document.createElement('div');
                warningDiv.style.cssText = `
                    position: fixed;
                    top: 80px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(255, 165, 2, 0.85);
                    color: white;
                    padding: 15px 25px;
                    border-radius: var(--border-radius);
                    z-index: 1000;
                    text-align: center;
                    max-width: 80%;
                    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
                    backdrop-filter: blur(5px);
                    border: 1px solid rgba(255, 255, 255, 0.15);
                    animation: fadeIn 0.3s ease-out;
                    line-height: 1.5;
                    letter-spacing: 0.5px;
                    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                `;
                warningDiv.textContent = message;
                
                // Add close button
                const closeBtn = document.createElement('span');
                closeBtn.textContent = 'Ã—';
                closeBtn.style.cssText = `
                    margin-left: 15px;
                    cursor: pointer;
                    font-weight: bold;
                    font-size: 22px;
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                    width: 28px;
                    height: 28px;
                    border-radius: 50%;
                    background: rgba(255, 255, 255, 0.15);
                    transition: all var(--transition-speed) ease;
                `;
                
                closeBtn.onmouseover = () => {
                    closeBtn.style.background = 'rgba(255, 255, 255, 0.3)';
                    closeBtn.style.transform = 'scale(1.1)';
                };
                
                closeBtn.onmouseout = () => {
                    closeBtn.style.background = 'rgba(255, 255, 255, 0.15)';
                    closeBtn.style.transform = 'scale(1)';
                };
                closeBtn.onclick = () => warningDiv.remove();
                warningDiv.appendChild(closeBtn);
                
                document.body.appendChild(warningDiv);
                
                // Auto-remove after 10 seconds
                setTimeout(() => {
                    if (warningDiv.parentNode) {
                        warningDiv.remove();
                    }
                }, 10000);
            }

            async toggleRecording() {
                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    this.startRecording();
                }
            }

            async startRecording() {
                if (!this.serverRunning) {
                    alert('Backend server is not running. Please wait for server to start.');
                    return;
                }

                // Start speech recognition without recording audio
                this.setupSpeechRecognition();
                this.isRecording = true;
                this.updateUI('recording');
                
                // Show the real-time transcription display
                this.realtimeTranscription.style.display = 'block';
                this.realtimeTranscriptionText.textContent = 'Listening...';
            }
            
            setupSpeechRecognition() {
                // Check if browser supports speech recognition
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                    this.recognition = new SpeechRecognition();
                    this.recognition.continuous = true;
                    this.recognition.interimResults = true;
                    
                    this.recognition.onresult = (event) => {
                        let interimTranscript = '';
                        let finalTranscript = '';
                        
                        for (let i = event.resultIndex; i < event.results.length; i++) {
                            const transcript = event.results[i][0].transcript;
                            if (event.results[i].isFinal) {
                                finalTranscript += transcript;
                            } else {
                                interimTranscript += transcript;
                            }
                        }
                        
                        // Update the real-time transcription display
                        this.realtimeTranscriptionText.textContent = finalTranscript || interimTranscript || 'Listening...';
                        
                        // Reset the silence timer whenever speech is detected
                        this.lastSpeechTime = Date.now();
                        
                        // Clear any existing timer
                        if (this.silenceTimer) {
                            clearTimeout(this.silenceTimer);
                        }
                        
                        // Set a new timer to check for silence
                        this.silenceTimer = setTimeout(() => {
                            const currentTime = Date.now();
                            const silenceDuration = currentTime - this.lastSpeechTime;
                            
                            // If silence duration exceeds threshold and we have transcription
                            if (silenceDuration >= this.silenceThreshold && 
                                this.realtimeTranscriptionText.textContent && 
                                this.realtimeTranscriptionText.textContent !== 'Listening...') {
                                console.log('Silence detected for 2 seconds, auto-sending...');
                                this.stopRecording();
                                this.sendRecording();
                            }
                        }, this.silenceThreshold);
                    };
                    
                    this.recognition.onerror = (event) => {
                        console.error('Speech recognition error:', event.error);
                    };
                    
                    this.recognition.start();
                } else {
                    console.warn('Speech recognition not supported in this browser');
                }
            }

            stopRecording() {
                if (this.isRecording) {
                    // Stop speech recognition
                    if (this.recognition) {
                        this.recognition.stop();
                    }
                    this.isRecording = false;
                    
                    // Clear the silence timer
                    if (this.silenceTimer) {
                        clearTimeout(this.silenceTimer);
                        this.silenceTimer = null;
                    }
                    
                    // Hide the real-time transcription display
                    this.realtimeTranscription.style.display = 'none';
                    
                    // Store the final transcription for sending
                    this.finalTranscription = this.realtimeTranscriptionText.textContent;
                    
                    // Automatically send the recording if there's content
                    if (this.finalTranscription && this.finalTranscription !== 'Listening...') {
                        this.sendRecording();
                    } else {
                        this.updateUI('ready');
                    }
                }
            }

            async sendRecording() {
                if (!this.finalTranscription || this.finalTranscription === 'Listening...') {
                    alert('No text transcribed. Please speak first.');
                    return;
                }
                
                this.updateUI('processing');
                
                // Display the final transcription
                this.displayTranscription(this.finalTranscription, 'en');
                
                // Send the transcription directly to the server
                await this.processTranscription();
            }

            async processTranscription() {
                try {
                    this.isProcessing = true;
                    
                    // Send the transcription text directly to the server
                    const response = await fetch('http://localhost:5000/process_text', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            text: this.finalTranscription,
                            language: 'en'
                        })
                    });

                    if (response.ok) {
                        // Start polling for AI response
                        this.startPollingForResponse();
                    } else {
                        throw new Error('Text processing failed');
                    }
                } catch (error) {
                    console.error('Error processing text:', error);
                    this.displayResult('Error: Could not process text. Please check server connection.');
                } finally {
                    this.isProcessing = false;
                }
            }
            
            async processAudio() {
                try {
                    this.isProcessing = true;
                    const audioBlob = new Blob(this.audioChunks, { type: 'audio/wav' });
                    const formData = new FormData();
                    formData.append('audio', audioBlob, 'recording.wav');

                    const response = await fetch('http://localhost:5000/transcribe', {
                        method: 'POST',
                        body: formData
                    });

                    if (response.ok) {
                        const result = await response.json();
                        
                        // Display transcription
                        if (result.transcription) {
                            this.displayTranscription(result.transcription, result.language);
                        }
                        
                        // Start polling for AI response
                        this.startPollingForResponse();
                        
                    } else {
                        throw new Error('Transcription failed');
                    }
                } catch (error) {
                    console.error('Error processing audio:', error);
                    this.displayResult('Error: Could not process audio. Please check server connection.');
                } finally {
                    this.isProcessing = false;
                }
            }

            async startPollingForResponse() {
                // Poll for AI response every 500ms
                this.pollingInterval = setInterval(async () => {
                    try {
                        const response = await fetch('http://localhost:5000/get_latest_response');
                        if (response.ok) {
                            const data = await response.json();
                            
                            if (data.text && data.text !== this.lastAiResponse) {
                                this.lastAiResponse = data.text;
                                this.displayResult(data.text, data.language);
                                
                                // Play AI response audio if available
                                if (data.has_audio) {
                                    this.playAudioResponse();
                                }
                                
                                // Stop polling once we get a response
                                clearInterval(this.pollingInterval);
                                this.updateUI('ready');
                            }
                        }
                    } catch (error) {
                        console.error('Error polling for response:', error);
                        clearInterval(this.pollingInterval);
                        this.updateUI('ready');
                    }
                }, 500);
                
                // Stop polling after 30 seconds max
                setTimeout(() => {
                    if (this.pollingInterval) {
                        clearInterval(this.pollingInterval);
                        this.updateUI('ready');
                    }
                }, 30000);
            }

            displayTranscription(text, language) {
                const transcriptionDiv = document.createElement('div');
                transcriptionDiv.className = 'transcription-overlay';
                transcriptionDiv.style.cssText = `
                    position: fixed;
                    top: 120px;
                    left: 30px;
                    background: rgba(26, 8, 78, 0.85);
                    padding: 15px 25px;
                    border-radius: var(--border-radius);
                    border: 1px solid rgba(255, 255, 255, 0.15);
                    color: var(--primary-color);
                    max-width: 350px;
                    z-index: 10;
                    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
                    backdrop-filter: blur(5px);
                    animation: fadeInLeft 0.3s ease-out;
                    line-height: 1.5;
                    letter-spacing: 0.5px;
                    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                `;
                transcriptionDiv.innerHTML = `You said: <span class="transcription-text">${text}</span> <span class="language-indicator">[${language}]</span>`;
                
                // Remove previous transcription
                const existing = document.querySelector('.transcription-display');
                if (existing) existing.remove();
                
                transcriptionDiv.className = 'transcription-display';
                document.body.appendChild(transcriptionDiv);
                
                // Auto-remove after 8 seconds
                setTimeout(() => {
                    if (transcriptionDiv.parentNode) {
                        transcriptionDiv.remove();
                    }
                }, 8000);
            }

            async playAudioResponse() {
                try {
                    const response = await fetch('http://localhost:5000/conversation_history');
                    if (response.ok) {
                        const data = await response.json();
                        const lastAiMessage = data.messages.filter(msg => msg.role === 'assistant').pop();
                        
                        if (lastAiMessage && lastAiMessage.has_audio) {
                            const audioUrl = `http://localhost:5000/get_audio/${this.sessionId}/${lastAiMessage.index}`;
                            
                            // Clean up any existing audio element
                            if (this.currentAudio) {
                                this.currentAudio.pause();
                                this.currentAudio.src = '';
                                this.currentAudio.load();
                                this.currentAudio = null;
                            }
                            
                            // Create and play audio
                            const audio = new Audio(audioUrl);
                            this.currentAudio = audio;
                            
                            // Visual feedback during audio playback
                            this.showAudioPlayback();
                            
                            // Display text in real-time
                            const text = lastAiMessage.content;
                            const words = text.split(' ');
                            let wordIndex = 0;
                            
                            // Create a container for real-time text display
                            const realtimeTextDiv = document.createElement('div');
                            realtimeTextDiv.className = 'realtime-text-display';
                            realtimeTextDiv.style.cssText = `
                                position: fixed;
                                top: 120px;
                                left: 50%;
                                transform: translateX(-50%);
                                background: rgba(26, 8, 78, 0.85);
                                padding: 15px 25px;
                                border-radius: var(--border-radius);
                                border: 1px solid rgba(255, 255, 255, 0.15);
                                color: var(--text-light);
                                max-width: 600px;
                                min-width: 300px;
                                text-align: center;
                                z-index: 10;
                                box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
                                backdrop-filter: blur(5px);
                                animation: fadeIn 0.3s ease-out;
                                line-height: 1.5;
                                letter-spacing: 0.5px;
                                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
                            `;
                            realtimeTextDiv.innerHTML = `<strong>AI is speaking:</strong><br><span id="realtime-text"></span>`;
                            
                            // Remove previous realtime text display if exists
                            const existing = document.querySelector('.realtime-text-display');
                            if (existing) existing.remove();
                            
                            document.body.appendChild(realtimeTextDiv);
                            const realtimeTextSpan = document.getElementById('realtime-text');
                            
                            // Calculate approximate word duration based on audio duration
                            audio.addEventListener('loadedmetadata', () => {
                                const audioDuration = audio.duration;
                                const wordDuration = audioDuration / words.length;
                                
                                // Start playing audio with proper error handling
                            audio.play().catch(e => {
                                console.log('Audio playback error:', e);
                                // Clean up on error
                                this.hideAudioPlayback();
                                // Display error message in realtime text
                                realtimeTextSpan.textContent = 'Audio playback failed. Please try again.';
                                // Attempt to recover by restarting playback after a delay
                                setTimeout(() => {
                                    if (this.currentAudio) {
                                        this.currentAudio.play().catch(e => console.log('Retry failed:', e));
                                    }
                                }, 1000);
                            });
                                
                                // Display words progressively
                                const wordInterval = setInterval(() => {
                                    if (wordIndex < words.length) {
                                        if (wordIndex === 0) {
                                            realtimeTextSpan.textContent = words[wordIndex];
                                        } else {
                                            realtimeTextSpan.textContent += ' ' + words[wordIndex];
                                        }
                                        wordIndex++;
                                    } else {
                                        clearInterval(wordInterval);
                                    }
                                }, wordDuration * 1000);
                            });
                            
                            audio.onended = () => {
                                // Ensure all text is displayed when audio ends
                                realtimeTextSpan.textContent = text;
                                
                                // Clean up audio resources through hideAudioPlayback
                                this.hideAudioPlayback();
                                
                                // Remove the realtime text display after a delay
                                setTimeout(() => {
                                    if (realtimeTextDiv.parentNode) {
                                        realtimeTextDiv.remove();
                                    }
                                    
                                    // Auto-start microphone after AI finishes speaking
                                    if (this.serverRunning && !this.isRecording) {
                                        this.toggleRecording();
                                    }
                                }, 1000); // Reduced delay to 1 second for better conversation flow
                            };
                        }
                    }
                } catch (error) {
                    console.error('Error playing audio response:', error);
                }
            }

            showAudioPlayback() {
                this.mic.style.filter = 'hue-rotate(120deg)';
                this.statusText.textContent = 'AI is speaking...';
            }

            hideAudioPlayback() {
                this.mic.style.filter = 'none';
                this.statusText.textContent = 'Ready to record';
                
                // Clean up audio resources
                if (this.currentAudio) {
                    this.currentAudio.pause();
                    this.currentAudio.src = '';
                    this.currentAudio.load();
                    this.currentAudio = null;
                }
            }

            displayResult(text, language = 'en') {
                // Display the result in the output panel
                this.outputPanel.style.display = 'block';
                this.outputText.innerHTML = `You said: <span class="transcription-text">${text}</span> <span class="language-indicator">[${language}]</span>`;
            }

            clearOutput() {
                // Clear transcription display
                const transcription = document.querySelector('.transcription-display');
                if (transcription) transcription.remove();
                
                // Clear output panel
                this.outputText.innerHTML = 'You said: ';
                
                // Clear session
                fetch('http://localhost:5000/clear_session', { method: 'POST' })
                    .then(() => this.startNewSession())
                    .catch(e => console.error('Error clearing session:', e));
            }

            updateUI(state) {
                switch (state) {
                    case 'recording':
                        this.mic.classList.add('recording');
                        this.statusText.textContent = 'Listening... Click to stop';
                        this.waveAnimation.style.display = 'block';
                        break;
                    
                    case 'processing':
                        this.mic.classList.remove('recording');
                        this.statusText.textContent = 'Processing text...';
                        this.waveAnimation.style.display = 'none';
                        break;
                    
                    case 'ready':
                    default:
                        this.mic.classList.remove('recording');
                        break;
                }
            }
            updateUIForState(state) {
                // Reset all states first
                this.micContainer.classList.remove('recording', 'processing');
                this.serverIndicator.classList.remove('recording', 'processing');

                switch (state) {
                    case 'recording':
                        this.micContainer.classList.add('recording');
                        this.serverIndicator.classList.add('recording');
                        this.statusText.textContent = 'Listening... Click to stop';
                        this.waveAnimation.style.display = 'block';
                        break;
                    case 'processing':
                        this.micContainer.classList.add('processing');
                        this.serverIndicator.classList.add('processing');
                        this.statusText.textContent = 'Processing text...';
                        this.waveAnimation.style.display = 'none';
                        break;
                    default: // 'ready'
                        // Ready state
                        this.statusText.textContent = 'Ready to record';
                        this.waveAnimation.style.display = 'none';
                        break;
                }
            }
        }

        // Initialize the voice recorder when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new VoiceRecorder();
        });

        // Simulate backend server startup (you would replace this with actual server startup)
        function startPythonBackend() {
            // In a real implementation, you would need to:
            // 1. Use a local server or electron app to run Python scripts
            // 2. Or have the backend already running
            // 3. Or use a different approach like WebAssembly for Python
            
            console.log('Backend server startup simulation');
            // This is just a placeholder - actual implementation would depend on your setup
        }
    </script>
</body>
</html>